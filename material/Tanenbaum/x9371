! 19

.SECT .TEXT
vecprint:
PUSH BP
MOV BP,SP
MOV CX,4(BP)
MOV BX,6(BP)
MOV SI,0
PUSH frmatkop
PUSH frmatstr
PUSH PRINTF
SYS
MOV -4(BP),frmatint
1: MOV DI,(BX)(SI)
MOV -2(BP),DI
SYS
INC SI
LOOP 1b
PUSH ’\n’
PUSH PUTCHAR
SYS
MOV SP,BP
RET

! 20
! 21
! 22
! 23
! 24
! 25
! 26
! 27
! 28
! 29
! 30
! 31
! 32
! 33
! 34
! 35
! 36
! 37
! 38
! 39
! 40
! 41

Figure C-16. The program arrayprt before debugging.

Lines 27 to 30 show how a string can be printed, and 31 to 34 show the printf
system call for an integer value. Note that the address of the string is pushed on
line 27, while on line 33 the value of the integer is moved onto the stack. In both
cases the address of the format string is the first argument of PRINTF. Lines 37 to
39 show how a single character can be printed using the putchar system call.
Now let us try assembling and running the program. When the command
as88 arrayprt.s

is typed, we get an operand error on line 28 of the file arrayprt.$. This file is generated by the assembler by combining the included files with the source file to get
a composite file that is the actual assembler input. To see where line 28 really is,
we have to examine line 28 of arrayprt.$. We cannot look at arrayprt.s to get the
line number because the two files do not match on account of the header being
included line by line in arrayprt.$. Line 28 in arrayprt.$ corresponds to line 7 in
arrayprt.s because the included header file, syscalnr.h, contains 21 lines.
One easy way to find line 28 of arrayprt.$ on UNIX is to type the command
head –28 arrayprt.$

which displays the first 28 lines of the combined file. The line at the bottom of the
listing is the one in error. In this way (or by using an editor and going to line 28)

736

ASSEMBLY LANGUAGE PROGRAMMING

APP. C

we see that the error is on line 7, which contains the SHR instruction. Comparing
this code with the instruction table in Fig. C-4 shows the problem: the shift count
has been omitted. The corrected line 7 should read
SHR CX,1

It is very important to note that the error must be corrected in the original source
file, arrayprt.s, and not in the combined source, arrayprt.$, as the latter is automatically regenerated every time the assembler is called.
The next attempt to assemble the source code file should succeed. Then the
tracer can be started by the command:
t88 arrayprt

During the tracing process, we can see that the output is not consistent with the
vector in the data segment. The vector contains: 3, 4, 7, 11, 3, but the values displayed start with: 3, 1024, ... . Clearly, something is wrong.
To find the error, the tracer can be run again, step by step, examining the state
of the machine just before the incorrect value is printed. The value to be printed is
stored in memory on lines 32 and 33. Since the wrong value is being printed, this
is a good place to see what is wrong. The second time through the loop, we see
that SI is an odd number, when clearly it should be an even number, as it is indexing through words, not bytes. The problem is on line 35. It increments SI by 1; it
should increment it by 2. To fix the bug, this line should be changed to
ADD SI,2

When this correction is made, the printed list of numbers is correct.
However, there is one more error waiting for us. When vecprint is finished and
returns, the tracer complains about the stack pointer. The obvious thing to check
