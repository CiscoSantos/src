microinstructions written on consecutive lines are executed consecutively.
However, sometimes the microprogrammer wants to branch away, either unconditionally or conditionally. The notation for unconditional branches is easy:
goto label

can be included in any microinstruction to explicitly name its successor. For example, most microinstruction sequences end with a return to the first instruction of
the main loop, so the last instruction in each such sequence typically includes
goto Main1

Note that the data path is available for normal operations even during a microinstruction that contains a goto. After all, every single microinstruction contains a
NEXT ADDRESS field. All goto does is instruct the microassembler to put a specific value there instead of the address where it has decided to place the microinstruction on the next line. In principle, every line should have a goto statement. As a
convenience to the microprogrammer, when the target address is the next line, it
may be omitted.
For conditional branches, we need a different notation. Remember that JAMN
and JAMZ use the N and Z bits, which are set based on the ALU output. Sometimes
we need to test a register to see if it is zero, for example. One way to do this would
be to run it through the ALU and store it back in itself. Writing
TOS = TOS

looks peculiar, although it does the job (setting the Z flip-flop based on TOS).
However, to make microprograms look nicer, we now extend MAL, adding two
new imaginary registers, N and Z, which can be assigned to. For example,

SEC. 4.3

AN EXAMPLE IMPLEMENTATION

271

Z = TOS

runs TOS through the ALU, thus setting the Z (and N) flip-flops, but it does not do a
store into any register. What using Z or N as a destination really does is tell the
microassembler to set all the bits in the C field of Fig. 4-5 to 0. The data path executes a normal cycle, with all normal operations allowed, but no registers are written to. Note that it does not matter whether the destination is N or Z; the microinstruction generated by the microassembler is identical. Programmers who intentionally choose the ‘‘wrong’’ one should be forced to work on a 4.77-MHz original
IBM PC for a week as punishment.
The syntax for telling the microassembler to set the JAMZ bit is
if (Z) goto L1; else goto L2

Since the hardware requires these two addresses to be identical in their low-order 8
bits, it is up to the microassembler to assign them such addresses. On the other
hand, since L2 can be anywhere in the bottom 256 words of the control store, the
microassembler has a lot of freedom in finding an available pair.
Normally, these two statements will be combined, for example,
Z = TOS; if (Z) goto L1; else goto L2

The effect of this statement is that MAL generates a microinstruction in which TOS
is run through the ALU (but not stored anywhere) so that its value sets the Z bit.
Shortly after Z has been loaded from the ALU condition bit, it is ORed into the
high-order bit of MPC, forcing the address of the next microinstruction to be
fetched from either L2 or L1 (which must be exactly 256 more than L2). MPC will
be stable and ready to use for fetching the next microinstruction.
Finally, we need a notation for using the JMPC bit. The one we will use is
goto (MBR OR value)

This syntax tells the microassembler to use value for NEXT ADDRESS and set the
JMPC bit so that MBR is ORed into MPC along with NEXT ADDRESS. If value is 0,
which is the normal case, it is sufficient to just write
goto (MBR)

Note that only the low-order 8 bits of MBR are wired to MPC (see Fig. 4-6), so the
issue of sign extension (i.e., MBR versus MBRU) does not arise here. Also note that
the MBR available at the end of the current cycle is the one used. A fetch started in
this microinstruction is too late to affect the choice of the next microinstruction.

4.3.2 Implementation of IJVM Using the Mic-1
We have finally reached the point where we can put all the pieces together.
Figure 4-17 is the microprogram that runs on Mic-1 and interprets IJVM. It is a
surprisingly short program—only 112 microinstructions total. Three columns are

272
Label
Main1
nop1
iadd1
iadd2
iadd3
isub1
isub2
isub3
iand1
iand2
iand3
ior1
ior2
ior3
dup1
dup2
pop1
pop2
pop3
swap1
swap2
swap3
swap4
swap5
swap6
bipush1
bipush2
bipush3
iload1
iload2
