D

Figure 7-18. Use of a DLL file by two processes.

A DLL is constructed by the linker from a collection of input files. In fact,
building a DLL file is very much like building an executable binary program,
except that a special flag is given to the linker to tell it to make a DLL. DLLs are
commonly constructed from collections of library procedures that are likely to be
needed by multiple processes. The interface procedures to the Windows system
call library and large graphics libraries are common examples of DLLs. The advantage o using DLLs is saving space in memory and on disk. If some common li-

548

THE ASSEMBLY LANGUAGE LEVEL

CHAP. 7

brary were statically bound to each program using it, it would appear in many executable binaries on the disk and in memory, wasting space. With DLLs, each library appears only once on disk and once in memory.
In addition to saving space, this approach makes it easy to update library procedures, even after the programs using them have been compiled and linked. For
commercial software packages, where the users rarely have the source code, using
DLLs means that the software vendor can fix bugs in the libraries by just distributing new DLL files over the Internet, without requiring any changes to the main
program binaries.
The main difference between a DLL and an executable binary is that a DLL
cannot be started and run on its own (because it has no main program). It also has
different information in its header. In addition, the DLL as a whole has several
extra procedures not related to the procedures in the library. For example, there is
one procedure that is automatically called whenever a new process is bound to the
DLL and another one that is automatically called whenever a process is unbound
from it. These procedures can allocate and deallocate memory or manage other resources needed by the DLL.
There are two ways for a program to bind to a DLL. In the first way, called
implicit linking, the user’s program is statically linked with a special file called an
import library that is generated by a utility program that extracts certain information from the DLL. The import library provides the glue that allows the user
program to access the DLL. A user program can be linked with multiple import libraries. When a program using implicit linking is loaded into memory for execution, Windows examines it to see which DLLs it uses and checks to see if all of
them are already in memory. Those that are not in memory are loaded immediately (but not necessarily in their entirety, since they are paged). Some changes are
then made to the data structures in the import libraries so the called procedures can
be located, somewhat analogous to the changes shown in Fig. 7-17. They also
have to be mapped into the program’s virtual address space. At this point, the user
program is ready to run and can call the procedures in the DLLs as though they had
been statically bound with it.
The alternative to implicit linking is (not surprisingly) explicit linking. This
approach does not require import libraries and does not cause the DLLs to be loaded at the same time the user program is. Instead, the user program makes an explicit call at run time to bind to a DLL, then makes additional calls to get the addresses of procedures it needs. Once these have been found, it can call the procedures. When it is all done, it makes a final call to unbind from the DLL. When the
last process unbinds from a DLL, the DLL can be removed from memory.
It is important to realize that a procedure in a DLL does not have any identity
of its own (as a thread or process does). It runs in the called’s thread and uses the
called’s stack for its local variables. It can have process-specific static data (as
well as shared data) and otherwise behaves the same as a statically-linked procedure. The only essential difference is how the binding to it is performed.

SEC. 7.4

LINKING AND LOADING

549

Dynamic Linking in UNIX
The UNIX system has a mechanism similar in essence to DLLs in Windows. It
is called a shared library. Like a DLL file, a shared library is an archive file containing multiple procedures or data modules that are present in memory at run time
and can be bound to multiple processes at the same time. The standard C library
and much of the networking code are shared libraries.
UNIX supports only implicit linking, so a shared library consist of two parts: a
host library, which is statically linked with the executable file, and a target
library, which is called at run time. While the details differ, the concepts are essentially the same as with DLLs.

7.5 SUMMARY
Although most programs can and should be written in a high-level language,
occasional situations exist in which assembly language is needed, at least in part.
Programs for resource-poor computers such as smart cards and embedded processors in small consumer devices like clock radios are potential candidates. An assembly language program is a symbolic representation for some underlying machine language program. It is translated to the machine language by a program
called an assembler.
When extremely fast execution is critical to the success of some application, a
better approach than writing everything in assembly language is to first write the
whole program in a high-level language, then measure where it is spending its
time, and finally rewrite only those portions of the program that are heavily used.
In practice, a small fraction of the code is usually responsible for a large fraction of
the execution time.
Many assemblers have a macro facility that allows the programmer to give
commonly used code sequences symbolic names for subsequent inclusion. Usually, these macros can be parameterized in a straightforward way. Macros are implemented by a kind of literal string-processing algorithm.
Most assemblers are two pass. Pass one is devoted to building up a symbol table for labels, literals, and explicitly declared identifiers. The symbols can either
be kept unsorted and then searched linearly, first sorted and then searched using binary search, or hashed. If symbols do not need to be deleted during pass one,
hashing is usually the best method. Pass two does the code generation. Some
pseudoinstructions are carried out on pass one and some on pass two.
Independently-assembled programs can be linked together to form an executable binary program that can be run. This work is done by the linker. Its primary tasks are relocation and binding of names. Dynamic linking is a technique in
which certain procedures are not linked until they are actually called. Windows
DLLs and UNIX shared libraries use dynamic linking.

550

THE ASSEMBLY LANGUAGE LEVEL

CHAP. 7

PROBLEMS
1. For a certain program, 2% of the code accounts for 50% of the execution time. Compare the following three strategies with respect to programming time and execution
time. Assume that it would take 100 man-months to write it in C, and that assembly
code is 10 times slower to write and four times more efficient.
a. Entire program in C.
b. Entire program in assembler.
c. First all in C, then the key 2% rewritten in assembler.
2. Do the considerations that hold for two-pass assemblers also hold for compilers?
a. Assume that the compilers produce object modules, not assembly code.
b. Assume that the compilers produce symbolic assembly language.
3. Most assemblers for the x86 have the destination address as the first operand and the
